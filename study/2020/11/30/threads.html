<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Multithreaded programming in C | Kyung Yun Lee</title> <meta name="author" content="Kyung Yun Lee"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%90%B6&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://kyungyunlee.github.io/study/2020/11/30/threads.html"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Kyung Yun </span>Lee</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Multithreaded programming in C</h1> <p class="post-meta">November 30, 2020</p> <p class="post-tags"> <a href="/blog/2020"> <i class="fas fa-calendar fa-sm"></i> 2020 </a>   ·   <a href="/blog/tag/cs"> <i class="fas fa-hashtag fa-sm"></i> CS</a>     ·   <a href="/blog/category/study"> <i class="fas fa-tag fa-sm"></i> study</a>   </p> </header> <article class="post-content"> <p>I am reviewing threads, as I work on my assignment, which builds multi-threaded server with I/O multiplexing.</p> <h3 id="briefly-about-threads">Briefly about threads</h3> <p>Threads are often referred to as light-weight processes, because they are literally lighter than processes. What’s lighter? The size of a thread instance (less memory) and therefore, saving creation and destruction time.</p> <p>They are often preferred over processes, when one needs to run large number of tasks and creating that many number of processes takes too much memory and time.</p> <p>There are different use cases for threads and processes, so use them appropriately by needs.</p> <p>For instance, chrome tabs are implemented as individual processes, because then if one tab is killed, the others will still remain safe.</p> <p><strong>Processes</strong></p> <ul> <li>Each process is independent (No sharing of memory between processes)</li> <li> <p>Communication between processes can be more difficult</p> </li> <li>Useful when security is an important issue to avoid sharing of memory.</li> </ul> <p><strong>Threads</strong></p> <ul> <li> <p>Threads are executed within processes (Every process has at least one thread : the main thread)</p> </li> <li>Share virtual address space, system memory along with other threads in the same process</li> <li>Has its own stack and registers</li> </ul> <h4 id="thread-related-functions-in-c">Thread-related functions in C</h4> <p><strong><code class="language-plaintext highlighter-rouge">pthread_create()</code></strong></p> <p>Obviously, we need to create a thread in order to use one. This call will create a thread from the main thread, which is a default thread that comes along with when a process starts.</p> <p><strong><code class="language-plaintext highlighter-rouge">pthread_join ()</code></strong></p> <p>Let’s say we run multiple threads and one of the threads take much much longer than the others. If we don’t call join, the main thread may exit before all the threads are done with their job. This will create zombie threads. Therefore, if it is necessary to wait for all the threads to finish their tasks, it is important to call join to guarantee that all threads are done before the program exits.</p> <p><strong><code class="language-plaintext highlighter-rouge">pthread_mutex_lock()</code></strong>, <strong><code class="language-plaintext highlighter-rouge">pthread_mutex_unlock()</code></strong></p> <p>As mentioned in the intro, threads share memory. They can read and write to the same data. If each task assigned to threads modifies shared data, this will result in unexpected error from race condition. Race condition happens when threads access and change the same data almost at the same instant, so they end up reading and modifying the wrong data. Therefore, to prevent this from happening, it is important to make reading and writing operations atomic, so that when one thread is accessing and doing whatever it wants with the data, no other threads can access that same data.</p> <p><strong><code class="language-plaintext highlighter-rouge">pthread_cond_signal()</code></strong>, <strong><code class="language-plaintext highlighter-rouge">pthread_cond_wait()</code></strong></p> <p>Condition variable is needed to improve cpu usage by keeping threads in waiting status until they receive some external signal, rather than making the thread constantly check for notification.</p> <h4 id="thread-pool">Thread pool</h4> <p>Creating thousands of threads for each job can be quite inefficient, especially in terms of memory. In this case, using thread pool would be a better choice. Thread pool makes use of limited number of threads by assigning multiple jobs to each thread. For instance, to execute 10,000 jobs, instead of creating 10,000 threads, we can create 100 threads and let each of them perform 100 jobs each.</p> <ol> <li>Create thread pool (ex. 10 threads). For each thread in the thread pool, it will constantly watch for a new task to be assigned.</li> <li>When a new task is created, put it into a queue.</li> <li>When a thread receives a new task, it will dequeue and handle the task.</li> </ol> <p>Use condition variable to improve the performance, so that each thread does not constantly check if a client arrived or not.</p> <p>Simple example of a server using thread pool.</p> <p>It recieves many client requests (100s, 1000s …) and it distributes the client requests into 10 threads.</p> <p>(This is not a full code, refer to the link in the reference section for the full code.)</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include ...
#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include ...
</span>
<span class="cp">#define SERVERPORT 22000
#define THREAD_POOL_SIZE 10 
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">SA_IN</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">SA</span><span class="p">;</span>

<span class="n">pthread_t</span> <span class="n">thread_pool</span><span class="p">[</span><span class="n">THREAD_POOL_SIZE</span><span class="p">];</span>
<span class="n">pthread_mutex_t</span> <span class="n">mutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">cond_var</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">pclient</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="c1">// Create threads </span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="o">&lt;</span><span class="n">THREAD_POOL_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_pool</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_func</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="c1">// Call socket(), bind(), listen() to open up the server socket </span>
  <span class="n">server_socket</span> <span class="o">=</span> <span class="n">Open_listenfd</span><span class="p">(</span><span class="n">SERVERPORT</span><span class="p">);</span>
  
  <span class="c1">// Don't end the connection until the server explicitly gets turned off.</span>
  <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Waiting for connections...</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">addr_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SA_IN</span><span class="p">);</span>
    
    <span class="c1">// When a client sends connect request, accept it </span>
    <span class="n">client_socket</span> <span class="o">=</span> <span class="n">Accept</span> <span class="p">(</span><span class="n">server_socket</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">client_addr</span><span class="p">,</span> <span class="p">(</span><span class="n">socklen_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr_size</span><span class="p">);</span>
    
    <span class="cm">/** THREAD POOL PART **/</span>
    <span class="c1">// Insert the new incoming client into the queue </span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pclient</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span> <span class="c1">// Using int pointer to meet the pthread_create function form.</span>
    <span class="o">*</span><span class="n">pclient</span> <span class="o">=</span> <span class="n">client_socket</span><span class="p">;</span> 
    <span class="c1">// Call lock when inserting the new client into the queue. </span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">enqueue</span><span class="p">(</span><span class="n">pclient</span><span class="p">);</span>
    <span class="c1">// Signal the thread that a new client came. </span>
    <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond_var</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">thread_func</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
  <span class="cm">/* This function is run in each thread */</span>
  
  <span class="c1">// Just continuously run without returning </span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">pclient</span><span class="p">;</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="c1">// Without condvar, this part will not exist, and the thread will constantly check if there is a client in the queue.</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">pclient</span> <span class="o">=</span> <span class="n">dequeue</span><span class="p">())</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
      <span class="c1">// If there is no client, wait until a signal arrives as a new client arrives.</span>
      <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond_var</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
      <span class="n">pclient</span> <span class="o">=</span> <span class="n">dequeue</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    
    <span class="c1">// If there is a client to handle, handle the client </span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pclient</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">){</span>
      <span class="n">handle_connection</span><span class="p">(</span><span class="n">pclient</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span> <span class="nf">handle_connection</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">pclient</span><span class="p">){</span>
  <span class="cm">/* Read client's message from client socket, 
  do whatever server needs to do to process the request  from the client, 
  return the result back to the client,
  and close the current socket. 
  */</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="parallelism-vs-concurrency">Parallelism vs concurrency</h4> <p><strong>Parallelism</strong> : Executing multiple tasks at the same time.</p> <p>Ex) Multi-processing in multi-core machine</p> <p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glok8asc1bj30en08vglk.jpg" alt="Screen Shot 2020-12-15 at 4.12.38 PM" style="zoom: 67%;"></p> <p><strong>Concurrency</strong> : Only one task can be executed at a time, but cpu utilization is maximized by selecting and running multiple tasks.</p> <p>Ex) Mult-tasking in single-core machine through time slicing.</p> <p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glousnk0z6j30h408q74a.jpg" alt="Screen Shot 2020-12-15 at 4.12.43 PM" style="zoom:67%;"></p> <h4 id="reference">Reference</h4> <ul> <li>[Programming with Threads by Jacob Sorber](https://www.youtube.com/playlist?list=PL9IEJIKnBJjFZxuqyJ9JqVYmuFZHr7CFM)</li> </ul> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Kyung Yun Lee. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>